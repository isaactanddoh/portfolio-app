name: Application CD Pipeline

on:
  push:
    branches: [ dev, staging, main ]
    paths:
      - '**'
      - '!.github/dependabot.yml'
      - '!.github/workflows/app-ci.yml'
      
permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: .
    environment:
      name: ${{ github.ref_name }}

    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.IAM_ROLE }}
          aws-region: eu-west-1

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Generate Image Tags
        id: tags
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          GIT_SHA=$(git rev-parse --short HEAD)
          ENVIRONMENT="${{ github.ref_name }}"
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "gitsha=$GIT_SHA" >> $GITHUB_OUTPUT
          echo "tags=${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPO }}:$ENVIRONMENT-$GIT_SHA-$TIMESTAMP" >> $GITHUB_OUTPUT
      
      - name: Build Image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          load: true
          tags: ${{ steps.tags.outputs.tags }}
          no-cache: true

      - name: Scan Image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.tags.outputs.tags }}
          format: 'table'
          output: 'trivy-results.json'
          exit-code: '1'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy Results
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results
          path: trivy-results.json

      - name: Upload Trivy Results to S3
        run: |
          REPORT_DIR="reports/${{ github.repository }}/${{ github.ref_name }}/${{ github.sha }}"
          aws s3 cp trivy-results.json "s3://${{ secrets.REPORTS_BUCKET }}/$REPORT_DIR/"

      - name: Push Image
        run: docker push ${{ steps.tags.outputs.tags }}
        
      - name: Download Task Definition
        id: download-taskdef
        run: |
          TASK_FAMILY="${{ secrets.ECS_FAMILY }}"
          aws ecs describe-task-definition \
            --task-definition $TASK_FAMILY \
            --query 'taskDefinition' \
            --output json > taskdef.json
          echo "task_family=$TASK_FAMILY" >> $GITHUB_OUTPUT

      - name: Render New Task Definition
        id: render-taskdef
        run: |
          # Read the task definition
          TASKDEF_CONTENT=$(cat taskdef.json)
          
          # Update the image in container definitions
          NEW_TASKDEF=$(echo "$TASKDEF_CONTENT" | jq --arg IMAGE "${{ steps.tags.outputs.tags }}" \
            '.containerDefinitions[0].image = $IMAGE')
          
          # Remove fields that shouldn't be included in register-task-definition
          NEW_TASKDEF=$(echo "$NEW_TASKDEF" | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
          
          # Save the new task definition
          echo "$NEW_TASKDEF" > new-taskdef.json
          
          if [ $? -ne 0 ]; then
            echo "Failed to create new task definition"
            exit 1
          fi

      - name: Register New Task Definition
        id: register-taskdef
        run: |
          NEW_TASKDEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "file://new-taskdef.json" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          if [ $? -ne 0 ]; then
            echo "Failed to register new task definition"
            exit 1
          fi
          
          echo "task_def_arn=$NEW_TASKDEF_ARN" >> $GITHUB_OUTPUT

      - name: Update ECS Service
        run: |
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_SERVICE }}
            
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE }} \
            --task-definition ${{ steps.register-taskdef.outputs.task_def_arn }} \
            --force-new-deployment

          # Wait for service to be stable after update
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_SERVICE }}

      - name: Verify Deployment
        run: |
          # Get the deployment status
          DEPLOY_STATUS=$(aws ecs describe-services \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_SERVICE }} \
            --query 'services[0].deployments[0].status' \
            --output text)
          
          if [ "$DEPLOY_STATUS" != "PRIMARY" ]; then
            echo "Deployment failed: Service not stable"
            exit 1
          fi
          
          echo "Deployment successful!"

      - name: Notify Slack
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          fields: repo,message,commit,author,action,eventName,ref,workflow,job,took
          text: |
            Deployment to ${{ github.ref_name }} environment ${{ job.status }}!
            Image: ${{ steps.tags.outputs.tags }}
            Task Definition: ${{ steps.register-taskdef.outputs.task_def_arn }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}